#include "ov7670.h"
#include "dwt_delay.h"
#include "main.h"
#include <stdio.h>


unsigned char wrOV7670Reg(unsigned char regID, unsigned char regDat) {
	startSCCB();
	if (0 == SCCBwriteByte(0x42)) {
		stopSCCB();
		return 0;
	}
	DWT_Delay(50);
	if (0 == SCCBwriteByte(regID)) {
		stopSCCB();
		return 0;
	}
	DWT_Delay(50);
	if (0 == SCCBwriteByte(regDat)) {
		stopSCCB();
		return 0;
	}
	stopSCCB();

	return 1;
}

unsigned char rdOV7670Reg(unsigned char regID, unsigned char *regDat) {
	startSCCB();
	if (0 == SCCBwriteByte(0x42)) {
		stopSCCB();
		return (0);
	}
	DWT_Delay(50);
	if (0 == SCCBwriteByte(regID)) {
		stopSCCB();
		return (0);
	}
	stopSCCB();

	DWT_Delay(50);

	startSCCB();
	if (0 == SCCBwriteByte(0x43)) {
		stopSCCB();
		return (0);
	}
	DWT_Delay(50);
	*regDat = SCCBreadByte();
	noAck();
	stopSCCB();
	return (1);
}

//(140,16,640,480) is good for VGA
//(272,16,320,240) is good for QVGA
/* config_OV7670_window */
void OV7670_config_window(unsigned int startx, unsigned int starty,
		unsigned int width, unsigned int height) {
	unsigned int endx;
	unsigned int endy;
	unsigned char temp_reg1, temp_reg2;
	unsigned char temp = 0;

	endx = (startx + width);
	endy = (starty + height + height);
	rdOV7670Reg(0x03, &temp_reg1);
	temp_reg1 &= 0xf0;
	rdOV7670Reg(0x32, &temp_reg2);
	temp_reg2 &= 0xc0;

	// Horizontal
	temp = temp_reg2 | ((endx & 0x7) << 3) | (startx & 0x7);
	wrOV7670Reg(0x32, temp);
	temp = (startx & 0x7F8) >> 3;
	wrOV7670Reg(0x17, temp);
	temp = (endx & 0x7F8) >> 3;
	wrOV7670Reg(0x18, temp);

	// Vertical
	temp = temp_reg1 | ((endy & 0x3) << 2) | (starty & 0x3);
	wrOV7670Reg(0x03, temp);
	temp = starty >> 2;
	wrOV7670Reg(0x19, temp);
	temp = endy >> 2;
	wrOV7670Reg(0x1A, temp);
}



void set_OV7670reg(void) {
	wrOV7670Reg(0x12, 0x80); //Reset SCCB
	HAL_Delay(50);

	wrOV7670Reg(0x12, 0x14);  //QVGA Size
	wrOV7670Reg(0x0c, 0x04); // 0x04 RGB565
	wrOV7670Reg(0x11, 0x02); // PCLK = CLK / 0x2 (5 ultimos bits)
	wrOV7670Reg(0x40, 0xD0); // RGB565
	wrOV7670Reg(0x8c, 0x00); // RGB444 Disable

	wrOV7670Reg(0x3a, 0x04);
	wrOV7670Reg(0x32, 0x80);
	wrOV7670Reg(0x17, 0x16);
	wrOV7670Reg(0x18, 0x04);
	wrOV7670Reg(0x19, 0x02);
	wrOV7670Reg(0x1a, 0x7b);
	wrOV7670Reg(0x03, 0x06);

	wrOV7670Reg(0x3e, 0x00);
	wrOV7670Reg(0x70, 0x3a);
	wrOV7670Reg(0x71, 0x35);
	wrOV7670Reg(0x72, 0x11);
	wrOV7670Reg(0x73, 0x00);
	wrOV7670Reg(0xa2, 0x00);

	//wrOV7670Reg(0x15 , 0x31);
	wrOV7670Reg(0x7a, 0x20);
	wrOV7670Reg(0x7b, 0x1c);
	wrOV7670Reg(0x7c, 0x28);
	wrOV7670Reg(0x7d, 0x3c);
	wrOV7670Reg(0x7e, 0x55);
	wrOV7670Reg(0x7f, 0x68);
	wrOV7670Reg(0x80, 0x76);
	wrOV7670Reg(0x81, 0x80);
	wrOV7670Reg(0x82, 0x88);
	wrOV7670Reg(0x83, 0x8f);
	wrOV7670Reg(0x84, 0x96);
	wrOV7670Reg(0x85, 0xa3);
	wrOV7670Reg(0x86, 0xaf);
	wrOV7670Reg(0x87, 0xc4);
	wrOV7670Reg(0x88, 0xd7);
	wrOV7670Reg(0x89, 0xe8);

	wrOV7670Reg(0x32, 0xb6);

	wrOV7670Reg(0x13, 0xff);
	wrOV7670Reg(0x00, 0x00);
	wrOV7670Reg(0x10, 0x00);
	wrOV7670Reg(0x0d, 0x00);
	wrOV7670Reg(0x14, 0x4e);
	wrOV7670Reg(0xa5, 0x05);
	wrOV7670Reg(0xab, 0x07);
	wrOV7670Reg(0x24, 0x75);
	wrOV7670Reg(0x25, 0x63);
	wrOV7670Reg(0x26, 0xA5);
	wrOV7670Reg(0x9f, 0x78);
	wrOV7670Reg(0xa0, 0x68);
//	wrOV7670Reg(0xa1, 0x03);//0x0b,
	wrOV7670Reg(0xa6, 0xdf);
	wrOV7670Reg(0xa7, 0xdf);
	wrOV7670Reg(0xa8, 0xf0);
	wrOV7670Reg(0xa9, 0x90);
	wrOV7670Reg(0xaa, 0x94);
	//wrOV7670Reg(0x13, 0xe5); 
	wrOV7670Reg(0x0e, 0x61);
	wrOV7670Reg(0x0f, 0x43);
	wrOV7670Reg(0x16, 0x02);
	wrOV7670Reg(0x1e, 0x37);
	wrOV7670Reg(0x21, 0x02);
	wrOV7670Reg(0x22, 0x91);
	wrOV7670Reg(0x29, 0x07);
	wrOV7670Reg(0x33, 0x0b);
	wrOV7670Reg(0x35, 0x0b);
	wrOV7670Reg(0x37, 0x3f);
	wrOV7670Reg(0x38, 0x01);
	wrOV7670Reg(0x39, 0x00);
	wrOV7670Reg(0x3c, 0x78);
	wrOV7670Reg(0x4d, 0x40);
	wrOV7670Reg(0x4e, 0x20);
	wrOV7670Reg(0x69, 0x00);
	wrOV7670Reg(0x6b, 0x4a);
	wrOV7670Reg(0x74, 0x19);
	wrOV7670Reg(0x8d, 0x4f);
	wrOV7670Reg(0x8e, 0x00);
	wrOV7670Reg(0x8f, 0x00);
	wrOV7670Reg(0x90, 0x00);
	wrOV7670Reg(0x91, 0x00);
	wrOV7670Reg(0x92, 0x00);
	wrOV7670Reg(0x96, 0x00);
	wrOV7670Reg(0x9a, 0x80);
	wrOV7670Reg(0xb0, 0x84);
	wrOV7670Reg(0xb1, 0x0c);
	wrOV7670Reg(0xb2, 0x0e);
	wrOV7670Reg(0xb3, 0x82);
	wrOV7670Reg(0xb8, 0x0a);
	wrOV7670Reg(0x43, 0x14);
	wrOV7670Reg(0x44, 0xf0);
	wrOV7670Reg(0x45, 0x34);
	wrOV7670Reg(0x46, 0x58);
	wrOV7670Reg(0x47, 0x28);
	wrOV7670Reg(0x48, 0x3a);

	wrOV7670Reg(0x59, 0x88);
	wrOV7670Reg(0x5a, 0x88);
	wrOV7670Reg(0x5b, 0x44);
	wrOV7670Reg(0x5c, 0x67);
	wrOV7670Reg(0x5d, 0x49);
	wrOV7670Reg(0x5e, 0x0e);

	wrOV7670Reg(0x64, 0x04);
	wrOV7670Reg(0x65, 0x20);
	wrOV7670Reg(0x66, 0x05);

	wrOV7670Reg(0x94, 0x04);
	wrOV7670Reg(0x95, 0x08);

	wrOV7670Reg(0x6c, 0x0a);
	wrOV7670Reg(0x6d, 0x55);
	wrOV7670Reg(0x6e, 0x11);
	wrOV7670Reg(0x6f, 0x9f);

	wrOV7670Reg(0x6a, 0x40);
	wrOV7670Reg(0x01, 0x40);
	wrOV7670Reg(0x02, 0x40);

	//wrOV7670Reg(0x13, 0xe7);
	wrOV7670Reg(0x15, 0x00);
	wrOV7670Reg(0x4f, 0x80);
	wrOV7670Reg(0x50, 0x80);
	wrOV7670Reg(0x51, 0x00);
	wrOV7670Reg(0x52, 0x22);
	wrOV7670Reg(0x53, 0x5e);
	wrOV7670Reg(0x54, 0x80);
	wrOV7670Reg(0x58, 0x9e);

	wrOV7670Reg(0x41, 0x08);
	wrOV7670Reg(0x3f, 0x00);
	wrOV7670Reg(0x75, 0x05);
	wrOV7670Reg(0x76, 0xe1);

	wrOV7670Reg(0x4c, 0x00);
	wrOV7670Reg(0x77, 0x01);

	wrOV7670Reg(0x3d, 0xc1);
	wrOV7670Reg(0x4b, 0x09);
	wrOV7670Reg(0xc9, 0x60);
	//wrOV7670Reg(0x41, 0x38);	
	wrOV7670Reg(0x56, 0x40);
	wrOV7670Reg(0x34, 0x11);
	wrOV7670Reg(0x3b, 0x02);
	wrOV7670Reg(0xa4, 0x89);

	wrOV7670Reg(0x96, 0x00);
	wrOV7670Reg(0x97, 0x30);
	wrOV7670Reg(0x98, 0x20);
	wrOV7670Reg(0x99, 0x30);
	wrOV7670Reg(0x9a, 0x84);
	wrOV7670Reg(0x9b, 0x29);
	wrOV7670Reg(0x9c, 0x03);
	wrOV7670Reg(0x9d, 0x4c);
	wrOV7670Reg(0x9e, 0x3f);

	wrOV7670Reg(0x09, 0x00);
	wrOV7670Reg(0x3b, 0xc2);

}



unsigned char OV7670_init(void) {
	// Quitar PowerDown
	HAL_GPIO_WritePin(CAM_PWD_GPIO_Port, CAM_PWD_Pin, GPIO_PIN_RESET);
	// Quitar Reset
	HAL_GPIO_WritePin(CAM_RST_GPIO_Port, CAM_RST_Pin, GPIO_PIN_SET);

	HAL_Delay(50);

	SCCB_GPIO_Config(); // io init..

	/*
	if (0 == wrOV7670Reg(0x12, 0x80)) //Reset SCCB
	{
		return 0;
	}
	HAL_Delay(50);
	set_OV7670reg();

	OV7670_config_window(272, 12, 320, 240); // set 240*320
	*/
	return 0x01; //ok
}

const uint8_t OV7670_reg[127][2] = { { 0x12, 0x80 },

// Image format
		{ 0x12, 0x14 },		// 0x14 = QVGA RGB. 0x10 QVGA YUV
		{ 0xc, 0x8 },       //
		{ 0x11, 0x40 },     //
		{ 0x40, 0xF0 },     //  0xF0 RGB555, 0xD0 RGB565
		{ 0x8c, 0x00 },     //  RGB444 Disable
		{ 0xb0, 0x84 },		//Color mode (Not documented??)

		// Hardware window
		{ 0x10, 0x00 },
		{ 0x11, 0x40},		//PCLK settings, 15fps
		{ 0x32, 0x80 },		//HREF
		{ 0x17, 0x17 },		//HSTART
		{ 0x18, 0x05 },		//HSTOP
		{ 0x03, 0x0a },		//VREF
		{ 0x19, 0x02 },		//VSTART
		{ 0x1a, 0x7a },		//VSTOP

		// Scalling numbers
		{ 0x70, 0x3a },		//X_SCALING
		{ 0x71, 0x35 },		//Y_SCALING
		{ 0x72, 0x11 },		//DCW_SCALING
		{ 0x73, 0xf0 },		//PCLK_DIV_SCALING
		{ 0xa2, 0x02 },		//PCLK_DELAY_SCALING

		// Matrix coefficients
		{ 0x4f, 0x80 }, //
		{ 0x50, 0x80 }, //
		{ 0x51, 0x00 }, //
		{ 0x52, 0x22 }, //
		{ 0x53, 0x5e }, //
		{ 0x54, 0x80 }, //
		{ 0x58, 0x9e },

		// Gamma curve values
		{ 0x7a, 0x20 }, //
		{ 0x7b, 0x10 }, //
		{ 0x7c, 0x1e }, //
		{ 0x7d, 0x35 }, //
		{ 0x7e, 0x5a }, //
		{ 0x7f, 0x69 }, //
		{ 0x80, 0x76 }, //
		{ 0x81, 0x80 }, //
		{ 0x82, 0x88 }, //
		{ 0x83, 0x8f }, //
		{ 0x84, 0x96 }, //
		{ 0x85, 0xa3 }, //
		{ 0x86, 0xaf }, //
		{ 0x87, 0xc4 }, //
		{ 0x88, 0xd7 }, //
		{ 0x89, 0xe8 },

		// AGC and AEC parameters
		{ 0xa5, 0x05 }, //
		{ 0xab, 0x07 }, //
		{ 0x24, 0x95 }, //
		{ 0x25, 0x33 }, //
		{ 0x26, 0xe3 }, //
		{ 0x9f, 0x78 }, //
		{ 0xa0, 0x68 }, //
		{ 0xa1, 0x03 }, //
		{ 0xa6, 0xd8 }, //
		{ 0xa7, 0xd8 }, //
		{ 0xa8, 0xf0 }, //
		{ 0xa9, 0x90 }, //
		{ 0xaa, 0x94 }, //

		// AWB parameters
		{ 0x43, 0x0a }, //
		{ 0x44, 0xf0 }, //
		{ 0x45, 0x34 }, //
		{ 0x46, 0x58 }, //
		{ 0x47, 0x28 }, //
		{ 0x48, 0x3a }, //
		{ 0x59, 0x88 }, //
		{ 0x5a, 0x88 }, //
		{ 0x5b, 0x44 }, //
		{ 0x5c, 0x67 }, //
		{ 0x5d, 0x49 }, //
		{ 0x5e, 0x0e }, //
		{ 0x6c, 0x0a }, //
		{ 0x6d, 0x55 }, //
		{ 0x6e, 0x11 }, //
		{ 0x6f, 0x9f }, //
		{ 0x6a, 0x40 }, //
		{ 0x01, 0x40 }, //
		{ 0x02, 0x60 }, //
		{ 0x13, 0xe7 },

		// Additional parameters
		{ 0x34, 0x11 }, //
		{ 0x3f, 0x00 }, //
		{ 0x75, 0x05 }, //
		{ 0x76, 0xe1 }, //
		{ 0x4c, 0x00 }, //
		{ 0x77, 0x01 }, //
		{ 0xb8, 0x0a }, //
		{ 0x41, 0x18 }, //
		{ 0x3b, 0x12 }, //
		{ 0xa4, 0x88 }, //
		{ 0x96, 0x00 }, //
		{ 0x97, 0x30 }, //
		{ 0x98, 0x20 }, //
		{ 0x99, 0x30 }, //
		{ 0x9a, 0x84 }, //
		{ 0x9b, 0x29 }, //
		{ 0x9c, 0x03 }, //
		{ 0x9d, 0x4c }, //
		{ 0x9e, 0x3f }, //
		{ 0x78, 0x04 }, //
		{ 0x0e, 0x61 }, //
		{ 0x0f, 0x4b }, //
		{ 0x16, 0x02 }, //
		{ 0x1e, 0x00 }, //
		{ 0x21, 0x02 }, //
		{ 0x22, 0x91 }, //
		{ 0x29, 0x07 }, //
		{ 0x33, 0x0b }, //
		{ 0x35, 0x0b }, //
		{ 0x37, 0x1d }, //
		{ 0x38, 0x71 }, //
		{ 0x39, 0x2a }, //
		{ 0x3c, 0x78 }, //
		{ 0x4d, 0x40 }, //
		{ 0x4e, 0x20 }, //
		{ 0x69, 0x00 }, //
		{ 0x6b, 0x3a }, //
		{ 0x74, 0x10 }, //
		{ 0x8d, 0x4f }, //
		{ 0x8e, 0x00 }, //
		{ 0x8f, 0x00 }, //
		{ 0x90, 0x00 }, //
		{ 0x91, 0x00 }, //
		{ 0x96, 0x00 }, //
		{ 0x9a, 0x00 }, //
		{ 0xb1, 0x0c }, //
		{ 0xb2, 0x0e }, //
		{ 0xb3, 0x82 }, //
		{ 0x4b, 0x01 }, };

void OV7670_config(void) {
	uint8_t data, i = 0;
	uint8_t err;

	// Configure camera registers
	for (i = 0; i < 127; i++) {
		data = OV7670_reg[i][1];
		err = wrOV7670Reg(OV7670_reg[i][0], data);

		if (err == 0) {
			printf("Failed to update register\n");
			break;
		}

		if(i==0){
			HAL_Delay(50);
		}
	}
}
